<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>math | Blog of James Brown</title>
  <meta name="author" content="James Brown">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Blog of James Brown"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/blog/atom.xml" title="Blog of James Brown" type="application/atom+xml">
  
  
    <link href="/blog/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/blog/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/blog/js/jquery-2.0.3.min.js"></script>
  
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/blog/">Blog of James Brown</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/blog/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/blog/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      

<!-- title -->
<div class="page-header page-header-inverse ">
  <h1 class="archive-title-tag title title-inverse ">math</h1>
</div>

<div class="row page">
  <!-- cols -->
  
  <div class="col-md-9">
	

	  <div id="top_search"></div>

      
         <!-- display as entry -->
	     <div class="mypage">
	       
		     
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2022-08-22 </div>
			<div class="article-title"><a href="/blog/2022/08/22/f8398512-6f0b-433a-ad9f-89f730d636f4/" title="This Python script utilizes SymPy for performing various interval operations. It allows you to manage, merge, and sort sets of intervals, detect overlaps, convert continuous data into intervals, solve unions, filter short intervals, and transform interval sets into tuples. The provided functions enable you to obtain a merged interval tuple list and easily handle and manipulate interval sets.">连续区间 离散区间 从离散数据中获得离散区间 交并补</a></div>
		</h3>
	


		     
<div class="entry">

  <div class="row">
	
	
		<p>离散区间的获得可以用边界条件判定 即最近n个连续的概率大于多少 容忍值为多少 最近n个小于多少直接作为结束边界的条件 也可以用convolution Gaussian blur</p>
<p>离散区间交并补可以转化为连续区间交并补 更简单省事</p>
<p>如果要做下面的运算 建议用第三方库 比如wolfram swi-prolog的clpr sympy</p>
<p>连续区间交并补 先排序 设置首末端的操作 然后进行相应区间选取 进行下一步操作直到结束 输出总的结果</p>
<h2 id="combining-similar-nearby-bounding-boxes-suppressing-near-duplicate-bounding-boxes-over-short-time"><a href="#combining-similar-nearby-bounding-boxes-suppressing-near-duplicate-bounding-boxes-over-short-time" class="headerlink" title="combining similar&#x2F;nearby bounding boxes, suppressing near duplicate bounding boxes over short time"></a>combining similar&#x2F;nearby bounding boxes, suppressing near duplicate bounding boxes over short time</h2><p><a href="./textbook!.md">see here</a></p>
<p>you can merge a group of things, then analyze them over time using object tracker, tweening them.</p>
<h2 id="Discrete-Interval-Set-Union-Solvers"><a href="#Discrete-Interval-Set-Union-Solvers" class="headerlink" title="Discrete Interval Set Union Solvers"></a>Discrete Interval Set Union Solvers</h2><p>you may want to filter out short intervals. mind the lopen&#x2F;ropen interval after intersection or difference operation.</p>
<p>you may also want to quantize these intervals, set them to nearest possible points. 用到某采样率 还是根本不用吧 就是属于那个区间的离散点上面执行相应的操作变化 但是那个区间如何划分 怎么把离散点归类到不同区间里面 完全是其他的逻辑需要做的事情 一般同类别的区间不能相交 但是之后再考虑吧 怎么用呢 所有的全部弄到一个列表里面 还是选取最小的那个来用？</p>
<p>category with different groups -&gt; subcategories</p>
<p>first the sample set:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import sympy</span><br><span class="line"><span class="comment"># make sure every subset is ordered.</span></span><br><span class="line">mSet = [(1.0,1.1,1.2),(2.4,2.5,2.6)]</span><br><span class="line">mSet2 = [(0.9,1.05,1.15),(2.45,2.55,2.65,2.75)]</span><br><span class="line"><span class="comment"># convert to intervals first please?</span></span><br><span class="line">mSetIntervals = [(x[0],x[-1]) <span class="keyword">for</span> x <span class="keyword">in</span> mSet]</span><br><span class="line">mSet2Intervals = [(x[0],x[-1]) <span class="keyword">for</span> x <span class="keyword">in</span> mSet2]</span><br><span class="line"><span class="comment"># additional check: these intervals cannot overlap!</span></span><br><span class="line">def checkOverlap(intervalTupleList):</span><br><span class="line">unionInterval = sympy.EmptySet <span class="comment"># shall be empty here.</span></span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> intervalTupleList:</span><br><span class="line">newInterval = sympy.Interval(start,end)</span><br><span class="line">isOverlapped = (sympy.EmptySet == unionInterval.intersect(newInterval))</span><br><span class="line"><span class="keyword">if</span> isOverlapped:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;INTERVAL&quot;</span>, newInterval, <span class="string">&quot;OVERLAPPED!&quot;</span>)</span><br><span class="line"><span class="built_in">return</span> isOverlapped</span><br><span class="line">unionInterval += newInterval</span><br><span class="line"><span class="built_in">return</span> False</span><br><span class="line">assert not checkOverlap(mSetIntervals)</span><br><span class="line">assert not checkOverlap(mSet2Intervals)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>then pool and sort all the boundaries of converted intervals:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mPoints = mSetIntervalBoundaries + mSet2IntervalBoundaries</span><br><span class="line">mPoints = list(<span class="built_in">set</span>(mPoints))</span><br><span class="line">mPoints.<span class="built_in">sort</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="with-sympy"><a href="#with-sympy" class="headerlink" title="with sympy"></a>with sympy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># all the same</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="with-less-sympy"><a href="#with-less-sympy" class="headerlink" title="with less sympy"></a>with less sympy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># all the same</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Continual-Interval-Set-Union-Solvers"><a href="#Continual-Interval-Set-Union-Solvers" class="headerlink" title="Continual Interval Set Union Solvers"></a>Continual Interval Set Union Solvers</h2><p>you must be able to explicitly point out different group index of different category. maybe you can just do it in all-new subcategories?</p>
<h3 id="less-exponential-solution-here"><a href="#less-exponential-solution-here" class="headerlink" title="less exponential solution here?"></a>less exponential solution here?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># basically the same example.</span></span><br><span class="line"><span class="comment"># assume no overlapping here.</span></span><br><span class="line">import sympy</span><br><span class="line">def unionToTupleList(myUnion):</span><br><span class="line">unionBoundaries = list(myUnion.boundary)</span><br><span class="line">unionBoundaries.<span class="built_in">sort</span>()</span><br><span class="line">leftBoundaries = unionBoundaries[::2]</span><br><span class="line">rightBoundaries = unionBoundaries[1::2]</span><br><span class="line"><span class="built_in">return</span> list(zip(leftBoundaries, rightBoundaries))</span><br><span class="line">def tupleSetToUncertain(mSet):</span><br><span class="line">mUncertain = None</span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> mSet:</span><br><span class="line"><span class="keyword">if</span> mUncertain is None:</span><br><span class="line">mUncertain = sympy.Interval(start,end)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mUncertain += sympy.Interval(start,end)</span><br><span class="line">typeUncertain = <span class="built_in">type</span>(mUncertain)</span><br><span class="line"><span class="built_in">return</span> mUncertain, typeUncertain</span><br><span class="line">def mergeOverlappedInIntervalTupleList(intervalTupleList):</span><br><span class="line">mUncertain, _ = tupleSetToUncertain(intervalTupleList)</span><br><span class="line">mUncertainBoundaryList = list(mUncertain.boundary)</span><br><span class="line">mUncertainBoundaryList.<span class="built_in">sort</span>()</span><br><span class="line">mergedIntervalTupleList = list(zip(mUncertainBoundaryList[::2], mUncertainBoundaryList[1::2]))</span><br><span class="line"><span class="built_in">return</span> mergedIntervalTupleList</span><br><span class="line">mSet = mergeOverlappedInIntervalTupleList([(0,1), (2,3)])</span><br><span class="line">mSet2 = mergeOverlappedInIntervalTupleList([(0.5,1.5),(1.6,2.5)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MSET&quot;</span>, mSet)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MSET2&quot;</span>, mSet2)</span><br><span class="line">mSetCandidates = [mSet, mSet2]</span><br><span class="line">mSetUnified = [x <span class="keyword">for</span> y <span class="keyword">in</span> mSetCandidates <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line">leftBoundaryList = <span class="built_in">set</span>([x[0] <span class="keyword">for</span> x <span class="keyword">in</span> mSetUnified])</span><br><span class="line">rightBoundaryList = <span class="built_in">set</span>([x[1] <span class="keyword">for</span> x <span class="keyword">in</span> mSetUnified])</span><br><span class="line"><span class="comment"># they may freaking overlap.</span></span><br><span class="line"><span class="comment"># if want nearby-merge strategy, simply just expand all intervals, merge them with union and shrink the individual intervals inside union respectively.</span></span><br><span class="line">markers = &#123;<span class="string">&quot;enter&quot;</span>:&#123;k:[] <span class="keyword">for</span> k <span class="keyword">in</span> leftBoundaryList&#125;, <span class="string">&quot;exit&quot;</span>:&#123;k:[] <span class="keyword">for</span> k <span class="keyword">in</span> rightBoundaryList&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> index, mSetCandidate <span class="keyword">in</span> enumerate(mSetCandidates):</span><br><span class="line">leftBoundaryListOfCandidate = [x[0] <span class="keyword">for</span> x <span class="keyword">in</span> mSetCandidate]</span><br><span class="line">rightBoundaryListOfCandidate = [x[1] <span class="keyword">for</span> x <span class="keyword">in</span> mSetCandidate]</span><br><span class="line"><span class="keyword">for</span> leftBoundaryOfCandidate <span class="keyword">in</span> leftBoundaryListOfCandidate:</span><br><span class="line">markers[<span class="string">&quot;enter&quot;</span>][leftBoundaryOfCandidate].append(index) <span class="comment"># remap this thing!</span></span><br><span class="line"><span class="keyword">for</span> rightBoundaryOfCandidate <span class="keyword">in</span> rightBoundaryListOfCandidate:</span><br><span class="line">markers[<span class="string">&quot;exit&quot;</span>][rightBoundaryOfCandidate].append(index) <span class="comment"># remap this thing!</span></span><br><span class="line"><span class="comment"># now, iterate through the boundaries of mSetUnified.</span></span><br><span class="line">unifiedBoundaryList = leftBoundaryList.union(rightBoundaryList) <span class="comment"># call me a set instead of a list please? now we must sort this thing</span></span><br><span class="line">unifiedBoundaryList = list(unifiedBoundaryList)</span><br><span class="line">unifiedBoundaryList.<span class="built_in">sort</span>()</span><br><span class="line">unifiedBoundaryMarks = &#123;&#125;</span><br><span class="line">finalMappings = &#123;&#125;</span><br><span class="line"><span class="comment"># print(&quot;MARKERS&quot;, markers)</span></span><br><span class="line"><span class="comment"># breakpoint()</span></span><br><span class="line"><span class="keyword">for</span> index, boundary <span class="keyword">in</span> enumerate(unifiedBoundaryList):</span><br><span class="line">previousMark = unifiedBoundaryMarks.get(index-1, [])</span><br><span class="line">enterList = markers[<span class="string">&quot;enter&quot;</span>].get(boundary,[])</span><br><span class="line">exitList = markers[<span class="string">&quot;exit&quot;</span>].get(boundary,[])</span><br><span class="line">currentMark = <span class="built_in">set</span>(previousMark + enterList).difference(<span class="built_in">set</span>(exitList))</span><br><span class="line">currentMark = list(currentMark)</span><br><span class="line">unifiedBoundaryMarks.update(&#123;index:currentMark&#125;)</span><br><span class="line"><span class="comment"># now, handle the change? or not?</span></span><br><span class="line"><span class="comment"># let&#x27;s just deal those empty ones, shall we?</span></span><br><span class="line"><span class="keyword">if</span> previousMark == []: <span class="comment"># inside it is empty range.</span></span><br><span class="line"><span class="comment"># elif currentMark == []:</span></span><br><span class="line"><span class="keyword">if</span> index == 0: <span class="built_in">continue</span> <span class="comment"># just the start, no need to note this down.</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">finalMappings.update(&#123;<span class="string">&quot;empty&quot;</span>:finalMappings.get(<span class="string">&quot;empty&quot;</span>,[])+[(unifiedBoundaryList[index-1], boundary)]&#125;)</span><br><span class="line"><span class="comment"># the end of previous mark! this interval belongs to previousMark</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">key = previousMark.copy()</span><br><span class="line">key.sort()</span><br><span class="line">key = tuple(key)</span><br><span class="line">finalMappings.update(&#123;key:finalMappings.get(key,[])+[(unifiedBoundaryList[index-1], boundary)]&#125;)</span><br><span class="line"><span class="comment"># also the end of previous mark! belongs to previousMark.</span></span><br><span class="line"><span class="comment">### NOW THE FINAL OUTPUT ###</span></span><br><span class="line">finalCats = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> finalMappings.items():</span><br><span class="line"><span class="comment"># value is an array containing subInterval tuples.</span></span><br><span class="line">value = mergeOverlappedInIntervalTupleList(value)</span><br><span class="line">finalCats.update(&#123;key: value&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;______________FINAL CATS______________&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(finalCats)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sympy-solution"><a href="#sympy-solution" class="headerlink" title="sympy solution"></a>sympy solution</h3><p>sympy seems to provide support for discrete and continuous interval? will that save any damn time anyway? i’m afraid no? maybe there’s a way!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unionToTupleList</span>(<span class="params">myUnion</span>):</span><br><span class="line"><span class="comment">#  seriously wrong. this will fuck up.</span></span><br><span class="line">unionBoundaries = <span class="built_in">list</span>(myUnion.boundary)</span><br><span class="line">unionBoundaries.sort()</span><br><span class="line">leftBoundaries = unionBoundaries[::<span class="number">2</span>]</span><br><span class="line">rightBoundaries = unionBoundaries[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(leftBoundaries, rightBoundaries))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tupleSetToUncertain</span>(<span class="params">mSet</span>):</span><br><span class="line">mUncertain = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> mSet:</span><br><span class="line"><span class="keyword">if</span> mUncertain <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">mUncertain = sympy.Interval(start,end)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">mUncertain += sympy.Interval(start,end)</span><br><span class="line">typeUncertain = <span class="built_in">type</span>(mUncertain)</span><br><span class="line"><span class="keyword">return</span> mUncertain, typeUncertain</span><br><span class="line"><span class="comment"># borrowed from above code.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeOverlappedInIntervalTupleList</span>(<span class="params">intervalTupleList</span>):</span><br><span class="line">mUncertain, _ = tupleSetToUncertain(intervalTupleList)</span><br><span class="line">mUncertainBoundaryList = <span class="built_in">list</span>(mUncertain.boundary)</span><br><span class="line">mUncertainBoundaryList.sort()</span><br><span class="line"><span class="comment">#  print(mUncertain)</span></span><br><span class="line"><span class="comment">#  print(mUncertainBoundaryList)</span></span><br><span class="line">mergedIntervalTupleList = <span class="built_in">list</span>(<span class="built_in">zip</span>(mUncertainBoundaryList[::<span class="number">2</span>], mUncertainBoundaryList[<span class="number">1</span>::<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># print(mergedIntervalTupleList)</span></span><br><span class="line"><span class="keyword">return</span> mergedIntervalTupleList</span><br><span class="line">mSet = [(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">3</span>)]</span><br><span class="line">mUncertain, typeUncertain = tupleSetToUncertain(mSet)</span><br><span class="line">unrolledMSet = <span class="built_in">list</span>(mUncertain.boundary)</span><br><span class="line"><span class="comment"># can be either sympy.sets.sets.Interval of sympy.sets.sets.Union</span></span><br><span class="line">mSet2 = [(<span class="number">0.5</span>,<span class="number">1.5</span>),(<span class="number">1.6</span>,<span class="number">2.5</span>)]</span><br><span class="line">mUncertain2, typeUncertain2 = tupleSetToUncertain(mSet2)</span><br><span class="line">unrolledMSet2 = <span class="built_in">list</span>(mUncertain2.boundary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MSET&quot;</span>, mSet)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MSET2&quot;</span>, mSet2)</span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># hypothetical mSet2 and mUncertain2! please complete the hypothetical shit and make it runnable!</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkCommon</span>(<span class="params">subInterval, masterInterval</span>):</span><br><span class="line"><span class="keyword">return</span> subInterval == sympy.Intersection(subInterval, masterInterval)</span><br><span class="line">mUncertains = [mUncertain, mUncertain2]</span><br><span class="line">subIntervals = <span class="built_in">list</span>(<span class="built_in">set</span>(unrolledMSet2 + unrolledMSet))</span><br><span class="line">subIntervals.sort()</span><br><span class="line">subIntervals = <span class="built_in">zip</span>(subIntervals[:-<span class="number">1</span>], subIntervals[<span class="number">1</span>:])</span><br><span class="line">subIntervals = <span class="built_in">list</span>(subIntervals)</span><br><span class="line"><span class="comment">#  breakpoint()</span></span><br><span class="line"><span class="comment"># for subIntervals, it&#x27;s still not real interval but tuple at above line.</span></span><br><span class="line">reversedCats = &#123;&#125;</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">subIntervalUnion = functools.reduce(<span class="keyword">lambda</span> a,b: a+b, mUncertains)</span><br><span class="line"><span class="keyword">for</span> subIntervalIndex, (start, end) <span class="keyword">in</span> <span class="built_in">enumerate</span>(subIntervals):</span><br><span class="line">subIntervalCandidate = sympy.Interval(start, end)</span><br><span class="line">reverseIndex = [] <span class="comment"># there must be at least one such index.</span></span><br><span class="line"><span class="keyword">for</span> index, uncertainCandidate <span class="keyword">in</span> <span class="built_in">enumerate</span>(mUncertains):</span><br><span class="line"><span class="keyword">if</span> checkCommon(subIntervalCandidate, uncertainCandidate):</span><br><span class="line">reverseIndex.append(index) <span class="comment"># this is the index of the in-common set of the original set list</span></span><br><span class="line">reversedCats.update(&#123;subIntervalIndex:reverseIndex&#125;) <span class="comment"># need to sort and index? or not to sort because this is already done?</span></span><br><span class="line">normalCats = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> reversedCats.items():</span><br><span class="line">v.sort()</span><br><span class="line">v = <span class="built_in">tuple</span>(v)</span><br><span class="line">normalCats.update(&#123;v:normalCats.get(v, [])+[k]&#125;)</span><br><span class="line"><span class="comment"># we only get interval, not the actural union period!</span></span><br><span class="line"><span class="comment"># how to get interval elements out of union structure for hell sake?</span></span><br><span class="line">finalCats = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> normalCats.items():</span><br><span class="line"><span class="comment"># now k is the original set index list, representing belonging of the below union.</span></span><br><span class="line"><span class="comment">#  print(subIntervals)</span></span><br><span class="line"><span class="comment">#  print(index)</span></span><br><span class="line"><span class="comment">#  print(v)</span></span><br><span class="line"><span class="comment">#  breakpoint()</span></span><br><span class="line">mFinalUnionCandidate = [subIntervals[index] <span class="keyword">for</span> index <span class="keyword">in</span> v]</span><br><span class="line"><span class="comment">## REPLACED ##</span></span><br><span class="line"><span class="comment"># mFinalUnionCandidate, _ = tupleSetToUncertain(mFinalUnionCandidate)</span></span><br><span class="line"><span class="comment">##### union to tuple list, could be replaced #####</span></span><br><span class="line"><span class="comment">#mFinalUnionCandidateBoundaryList = list(mFinalUnionCandidate.boundary)</span></span><br><span class="line"><span class="comment">#left_bounds, right_bounds = mFinalUnionCandidateBoundaryList[0::2],mFinalUnionCandidateBoundaryList[1::2] # check it dammit! not sure how to step the list properly?</span></span><br><span class="line"><span class="comment">#mFinalIntervalListCandidate = list(zip(left_bounds, right_bounds))</span></span><br><span class="line"><span class="comment"># mFinalIntervalListCandidate = unionToTupleList(mFinalUnionCandidate)</span></span><br><span class="line"><span class="comment">##### union to tuple list, could be replaced #####</span></span><br><span class="line"><span class="comment">## REPLACED ##</span></span><br><span class="line"><span class="comment"># print(&quot;M_FINAL_UNION_CANDIDATE&quot;,mFinalUnionCandidate)</span></span><br><span class="line">mFinalIntervalListCandidate = mergeOverlappedInIntervalTupleList(mFinalUnionCandidate)</span><br><span class="line"><span class="comment"># print(&quot;M_FINAL_INTERVAL_LIST_CANDIDATE&quot;, mFinalIntervalListCandidate)</span></span><br><span class="line"><span class="comment"># breakpoint()</span></span><br><span class="line">finalCats.update(&#123;k:mFinalIntervalListCandidate.copy()&#125;)</span><br><span class="line"><span class="comment"># this whole calculation could just be exponential. goddamn it?</span></span><br><span class="line"><span class="comment"># before that, we need to get the &quot;empty&quot; out. but is that really necessary? i think it is, as an important feature.</span></span><br><span class="line"><span class="comment">#  subIntervalsStart, subIntervalsEnd = subIntervals[0][0], subIntervals[-1][-1]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  relativeCompleteInterval = sympy.Interval(subIntervalsStart, subIntervalsEnd)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># subIntervalUnion</span></span><br><span class="line"><span class="comment">#  emptyIntervalUnion = relativeCompleteInterval - subIntervalUnion # really uncertain if it is just a union or not.</span></span><br><span class="line"><span class="comment">#  emptyIntervalTupleList = unionToTupleList(emptyIntervalUnion)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  finalCats.update(&#123;&quot;empty&quot;:emptyIntervalTupleList&#125;)</span></span><br><span class="line">finalCats.update(&#123;<span class="string">&quot;empty&quot;</span>:finalCats[()]&#125;)</span><br><span class="line"><span class="keyword">del</span> finalCats[()]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_____FINAL CATS_____&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(finalCats)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/blog/2022/08/22/f8398512-6f0b-433a-ad9f-89f730d636f4/#more" class="btn btn-default more">Read More</a>
</div>

	       
	     </div>
	     <div>
	       <center>
	         <div class="pagination">
<ul class="pagination">
	 
</ul>
</div>

	       </center>
	     </div>	
      

</div> <!-- col-md-9/col-md-12 -->


<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/james4ever0/agi_computer_control/" title="Autonomous computer agent" target="_blank"]);">Project Cybergod</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/james4ever0/pyjom/" title="Media content automation" target="_blank"]);">Project Pyjom</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/james4ever0/prometheous/" title="Automated documentation, AI+IR(RAG)" target="_blank"]);">Project Prometheus</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/james4ever0/pyjom/" title="Media Content Automation" target="_blank"]);">Project Pyjom</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/james4ever0/my_blog_source/" title="Source code of my blog"" target="_blank"]);">Blog Source Code</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/james4ever0" title="My Github account" target="_blank"]);">My Github</a></li>
	
		<li><i class="fa fa-book"></i><a href="https://samoyedsun.github.io/" title="Samoyedsun's Blog" target="_blank"]);">Samoyedsun&#39;s Blog</a></li>
	
		<li><i class="fa fa-book"></i><a href="http://atlant1c.cn/" title="Atlant1c's Blog" target="_blank"]);">Atlant1c&#39;s Blog</a></li>
	
		<li><i class="fa fa-book"></i><a href="https://www.gregoryuan.com/" title="Gregoryuan's Blog" target="_blank"]);">Gregoryuan&#39;s Blog</a></li>
	
		<li><i class="fa fa-book"></i><a href="https://yubingtao.netlify.app/" title="Yubingtao's Blog" target="_blank"]);">Yubingtao&#39;s Blog</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <p>
  &copy; 2024 James Brown
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>
<script src="/blog/js/bootstrap.min.js"></script>
<script src="/blog/js/main.js"></script>
<script src="/blog/js/search.js"></script> 


<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/blog/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


</body>
</html>